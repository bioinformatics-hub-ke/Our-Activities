# RNASeq

# RNASeq

RNA sequencing (RNASeq) is a powerful and widely used technique for studying **gene expression** and **transcriptome profiling**. It involves sequencing the RNA molecules present in a biological sample, allowing researchers to identify and quantify the RNA transcripts that are present. RNASeq can be used to investigate a range of biological questions, including identifying differentially expressed genes, characterizing alternative splicing events, and detecting novel transcripts.

One of the major advantages of RNASeq is its ability to detect lowly expressed genes and quantify transcript abundance with high accuracy. This makes it a valuable tool for studying rare cell populations or subtle changes in gene expression. RNASeq can also be used to study non-coding RNAs, such as microRNAs and long non-coding RNAs, which have been implicated in a range of biological processes.

RNASeq has become increasingly accessible and affordable in recent years, with a range of commercial and open-source software tools available for analysis. However, RNASeq data analysis can be complex, and requires careful consideration of experimental design, normalization methods, and statistical analysis. Multiple factors affect the tools chosen to carry out analysis, and the workings of these tools have to be well understood to select the best one to carry out analysis. This tool hub will focus on the steps of RNASeq analysis, focusing on the tools available for each step, and the commands to run the steps.

## Datasets

We will use a public dataset from the [Galaxy RNASeq]( https://training.galaxyproject.org/training-material/topics/transcriptomics/tutorials/ref-based/tutorial.html) tutorial. We use the subsampled data for our steps, but the large datasets are also available for use. The datasets are in fastqsanger format, which is similar to fastq format

```bash
## You can use wget or curl to get the datasets. Or a for loop
https://zenodo.org/record/6457007/files/GSM461177_1_subsampled.fastqsanger
https://zenodo.org/record/6457007/files/GSM461177_2_subsampled.fastqsanger
https://zenodo.org/record/6457007/files/GSM461180_1_subsampled.fastqsanger
https://zenodo.org/record/6457007/files/GSM461180_2_subsampled.fastqsanger
```

## Steps

### 1. Quality control and Trimming

This step involves removing errors introduced during the sequencing process. Different sequence platforms may cause different errors. Trimming is also necessary where adapters are present, and the reads are longer than the fragments sequenced. 

Your input at this point is fastq or fasta reads, and in most cases paired-end reads (_1.fastq and _2 .fastq in our case). The output of the fastqc or multiqc steps are reports that guide on the type of trimming to be done. These two tools are relatively ‘lightweight’ in terms of computational resources, and can run on a local PC.  

- FastQC - Check out the documentation here:  https://github.com/s-andrews/FastQC
- MultiQC - MultiQC can aggregate reports of multiple samples: https://github.com/ewels/MultiQC

The adapter trimming comes after checking the quality of the sequences. 

- Cutadapt - [https://cutadapt.readthedocs.io/en/stable/](https://cutadapt.readthedocs.io/en/stable/)
- TrimGalore - https://github.com/FelixKrueger/TrimGalore

Another quality check is conducted using FastQC or multiQC tools to check if the quality has improved. 

Each of these tools have man pages to guide their installation and use. Here are the basic commands of the tools:

* Quality Control
  
```bash
## Fastqc basic syntax
fastqc input.fastq

# To run quality check on all our sample datasets use wildcards(*) to select all files ending with .fastqsanger
fastqc ./*.fastqsanger

## Multiqc basic syntax
multiqc [directory contain the fastq html reports]

#If the reports are in the current working directory use
multiqc .
```
* Sample quality plot generated by multiqc

![fastqc_per_base_sequence_quality_plot (4)](https://github.com/Parcelli/Our-Activities/assets/85280870/40a98584-e300-46ee-94b3-be527594e9c4)

* Trimming

**Cutadapt** trims  adapter sequences, primers,and any unwanted sequence from your fastq data.

```
#Cutadapt basic syntax
cutadapt -a AACCGGTT -o output.fastq input.fastq
#The sample data used doesn't have adapters.But if the would contain adapters we would run cutadapt as follows

cutadapt -a AACCGGTT -o GSM461177_1_trimmed.fastqsanger GSM461177_1_subsampled.fastqsanger

#-a - sequence of adapter. Replace the AACCGGTT with the adapter sequence in your data
#-o  the output for trimmed reads
```

**TrimGalore** is a perl wrapper around Cutadapt and FastQC.
```
#Basic trimgalore syntax
trim_galore [options] <filename(s)>

#Trimgalore run on our sample dataset
trim_galore \
--paired GSM461177_1_subsampled.fastqsanger  GSM461177_2_subsampled.fastqsanger \
--quality 30 \
--fastqc \
--nextera \
--output_dir results/clean_reads

#--paired - indicates trimming to performed on paired-end data
#--quality - trim low quality ends from reads
#--nextera - type of adapter sequence. If need be replace with 
#--output_dir - all outputs will be written to this directory

```




### 2. Mapping

Post-sequencing we get sequences ,but we do not know there genomic positions. We need to find the position of each gene on the organisms genome. To do this we ‘map’ or align the reads to the reference genome, if the genome exists.Multiple tools have been designed to do mapping and can be sample specific.These step is usually computationally intensive and in most cases fails on local computers. Cloud computing or running the analysis in a cluster might be a solution if analysis fails on a local PC. 

The input of these tools are a reference genome & FASTA/Q reads and the output is SAM/BAM files. Some common tools include:

- Bowtie2 - https://github.com/BenLangmead/bowtie2
- SOAP - [http://gaow.github.io/genetic-analysis-software/s/soap/](http://gaow.github.io/genetic-analysis-software/s/soap/)
- STAR - https://github.com/alexdobin/STAR
- HISAT - https://github.com/DaehwanKimLab/hisat2
- TopHat -https://github.com/infphilo/tophat

**Bowtie2**

Bowtie2 is a popular alignment tool in bioinformatics written by [Ben Langmead](https://github.com/BenLangmead) at Johns Hopkins University in C++.
It is designed to be fast and memory efficient. Bowtie2 is known to be good at aligning relatively long genomes for example,human genome.Before performing alignment,Bowtie2 builds an index of reference genome. The index allows for quick retrieval of reference sequences during alignment. 
Bowtie2 uses Burrows-Wheeler Transform (BWT) algorithmn to align reads to the reference genome.Bowtie2 offers both local alignment and end to end alignment mode.To learn more on difference between local alignment and end to end alignment check bowtie github [repo](https://github.com/BenLangmead/bowtie2/blob/521c3230af6c068d7d9f68264db0f01cfb5f0cbb/MANUAL.markdown).

* Installation
  
Bowtie2 can be installed via various package managers. To install using [bioconda](https://anaconda.org/bioconda/bowtie2) use: 

```
conda install -c bioconda bowtie2
```

* Alignment using Bowtie2
  
```
#Downloading the drosophila melanogaster reference genome from Ensembl

mkdir references
cd references
#dowloading the fasta & gtf files using curl command

curl -O ftp://ftp.ensembl.org/pub/release-109/fasta/drosophila_melanogaster/dna/Drosophila_melanogaster.BDGP6.32.dna.toplevel.fa.gz
curl -O ftp://ftp.ensembl.org/pub/release-109/gtf/drosophila_melanogaster/Drosophila_melanogaster.BDGP6.32.109.gtf.gz


!/bin/bash

# Building an index
bowtie2-build ./references/Drosophila_melanogaster.BDGP6.32.dna.toplevel.fa.gz ./references/drosophila_melanogaster

#Incase of single/unpaired reads
# Aligning unpaired reads
#bowtie2 -x ./reference/drosophila_melanogaster  -U example/reads/longreads.fq

# Aligning paired reads
bowtie2 -x ./references/drosophila_melanogaster \
-1 GSM461177_1_subsampled.fastqsanger \
-2 GSM461177_2_subsampled.fastqsanger \
-S GSM461177.sam

#-x prefix for the index files of the reference genome
#-U list of unpaired files separated by a comma to be mapped
#-1 comma-separated list of forward reads(reads_1.fq)
#-2 comma-separated list of reverse reads(reads_2.fq)
#-S 

```
* Sample mapping statistics

The percentage of mapped reads is an important alignment quality indicator.An overall alignment rate of 70% and above is generally good.

```
  1057657 reads; of these:
  1057657 (100.00%) were paired; of these:
    204963 (19.38%) aligned concordantly 0 times
    721322 (68.20%) aligned concordantly exactly 1 time
    131372 (12.42%) aligned concordantly >1 times
    ----
    204963 pairs aligned concordantly 0 times; of these:
      46878 (22.87%) aligned discordantly 1 time
    ----
    158085 pairs aligned 0 times concordantly or discordantly; of these:
      316170 mates make up the pairs; of these:
        219095 (69.30%) aligned 0 times
        87581 (27.70%) aligned exactly 1 time
        9494 (3.00%) aligned >1 times
89.64% overall alignment rate
```

**STAR**

STAR Aligner(Spliced Transcripts Alignment to a Reference)

STAR is a splice aware aligner designed to specifically address many of the challenges of RNA-seq data.It shows high accuracy and mapping speed. 
* Installation using bioconda
  
```
conda install -c bioconda star
```

Alignment in STAR involves two steps;


* Creating genome index

```
STAR --runMode genomeGenerate \
--genomeDir ./starr #path to store genome indices\
--genomeFastaFiles Drosophila_melanogaster.BDGP6.32.dna.toplevel.fa \
--sjdbGTFfile Drosophila_melanogaster.BDGP6.32.109.gtf \
--sjdbOverhang 99 #readlength-1 \
--sjdbGTFtagExonParentTranscript gene

#You can specify number of threads using --runThreadN 6  # number of threads
```
* Mapping reads to the genome

```
STAR \
--genomeDir ./starr \
--readFilesIn  GSM461177_1_subsampled.fastqsanger GSM461177_2_subsampled.fastqsanger \
--outSAMtype BAM SortedByCoordinate \
--quantMode GeneCounts \
--outFileNamePrefix GSM461177


```

**HISAT2**

hisat2 is a fast and sensitive splice-aware aligner that compresses the genome using an indexing scheme to reduce the amount of space needed to store the genome. This also makes the genome quick to search, using a whole-genome index.We use samtools to convert the output file from mapping to bam format and to index the bam files.Indexing creates a searchable index of sorted bam files required in some programs. 

* Installing Hisat2 using bioconda

```
conda install -c bioconda hisat2
```

* Mapping
  
It is important to note that hisat2 requires an **unzipped reference genome** for building an index.

```
#Unzip reference genome
gzip -d Drosophila_melanogaster.BDGP6.32.dna.toplevel.fa.gz

#Build index
mkdir hisat-map
hisat2-build -p25 ./references/Drosophila_melanogaster.BDGP6.32.dna.toplevel.fa ./hisat-map/Drosophila_melanogaster.idx

#Run hisat2 using indexed reference

mkdir Alignment_hisat
hisat2 -x ./hisat-map/Drosophila_melanogaster.idx \
-1 GSM461177_1_subsampled.fastqsanger \
-2 GSM461177_2_subsampled.fastqsanger \
-S GSM461177_hisat.sam \

#-X prefix for index files
#-S sam output

#Converting sam to bam files since sam files are quite huge

samtools view -Sb GSM461177_hisat.sam | samtools sort  > GSM461177_hisat_sorted.bam
samtools index GSM461177_hisat_sorted.bam
rm GSM461177_hisat.sam 
done

```
**TopHat2**

TopHat is bioinformatics tool designed for mapping RNA seq reads.It is able to handle splice junctions present in RNA-Seq reads. The [TopHat]( https://github.com/DaehwanKimLab/tophat/blob/master/AUTHORS) tool was written by Cole Trapnell and further developed by Daehwan Kim and Geo Pertea
leading to the release of TopHat2.
TopHat2 aligns reads to the reference genome using Bowtie2 then analyzes the mapping results to identify splice junctions.The tool can be run Linux, macOS, and Windows systems. 

* Installing TopHat2 using bioconda

```
conda install -c bioinfo tophat2
```
* Alignment using TopHat2
Inorder to perform alignment using TopHat2 you will require the Bowtie2 and Samtools in your environment.Both tools can be installed using [bioconda](https://anaconda.org/bioconda/)

```
# Building index for reference genome

bowtie2-build ./references/Drosophila_melanogaster.BDGP6.32.dna.toplevel.fa.gz ./references/drosophila_melanogaster

# Basic syntax for running TopHat2

tophat2 -o tophat_output –no-coverage-search /path/to/genome/Bowtie2Index/genome file_1.fastq file_2.fastq
samtools sort -n tophat_out/accepted_hits.bam_sorted

#-o output directory
#–no-coverage-search
# -n indicates sort by read names
```

**Memory & Time considerations during Mapping**

Mapping run time depends on the size of datasets, number of processors/threads as well as the alignment tool chosen.Here we provide the memory footprint of three mapping tools as documented in github pages.

Dataset: Human genome & mammals

| Tool    | Memory footprint |
| ----------- | ----------- |
| Bowtie2   |   3.2 GB     |
| STAR |   16 GB  |
| HISAT | 6.7 GB   |


### 3.Feature counting

Once you have your aligned reads,the next step is to count number of reads that mapped to each gene/feauture.A feature is an interval on a chromosome.The input is the bam files generated from mapping step and the output is a table containing gene-ids,sample_id and counts.This table will be used downstream for differential expression analysis.

* Tools for feature counting
  - htseq - https://github.com/htseq/htseq
  - featurescount : 

**HTSeq **
HTseq is a python library for analysis of High Throughput sequencing data. Htseq count is script in HTSeq used to quantify reads aligned to a feature in alignment files(sam or bam).htseq-count takes in the alignment file and an annotation file(gff or gtf) and outputs a table containing read counts for each feature in the annotation file.

An important consideration to be made at this step is how to deal with reads that align to more than one feature. htseq-count allows you to select between the three [modes](https://htseq.readthedocs.io/en/master/htseqcount.html#htseqcount) ; union,intersection-strict and intersection-nonempty.


* Installation
  ```
  #Using bioconda
  conda install -c bioconda htseq
* Basic syntax
  
```
htseq-count -t exon -i gene_id -f bam *._hisat_sorted.bam  VectorBase-53_AgambiaePEST.gff > htseq/counts.txt

```
**featuresCount**





  



### 3. Analysis of the deferentially expressed genes
